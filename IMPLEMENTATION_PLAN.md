# 问题管理插件 (Issue Manager) - 用户故事驱动的实施规划

本文档将插件的开发过程分解为五个核心里程碑，每个里程碑都围绕一个或多个核心用户故事展开。这种方式旨在确保每个开发阶段都交付明确的用户价值，并方便进行功能验收。

---

## 里程碑一：首次运行体验与基本知识库 (Milestone 1: The First Run Experience)

**核心用户故事**: “作为一名新用户，我希望能轻松完成插件的初始配置。配置成功后，我希望能**创建新笔记**，并立即看到一个我指定目录下的所有笔记的列表，并且可以点击列表中的任何一项来打开对应的文件。”

**验收场景 (Acceptance Scenarios)**:

- [ ] **场景1：未配置启动** - 当 `issueManager.issueDir` 未设置时，`问题总览`、`孤立问题` 和 `关注问题` 三个视图均显示引导信息和“立即配置”按钮。
- [ ] **场景2：配置引导** - 点击“立即配置”按钮后，工作区的 `settings.json` 文件会被打开，并且光标聚焦到 `issueManager.issueDir` 配置项。
- [ ] **场景3：配置后加载** - 当我设置一个包含 `.md` 文件的有效目录并保存后，`孤立问题` 视图会加载并以扁平列表形式显示所有 `.md` 文件。
- [ ] **场景4：打开文件** - 在 `孤立问题` 视图中单击任意文件项，对应的 Markdown 文件会在编辑器中打开。
- [ ] **场景5：创建文件** - 执行 `issueManager.createIssue` 命令，输入标题后，一个新的 `.md` 文件被创建在 `issueDir` 中，并出现在 `孤立问题` 视图里，同时在编辑器中打开。
- [ ] **场景6：删除文件** - 在 `孤立问题` 视图中右键点击一个问题，选择“删除”并确认后，对应的 `.md` 文件会从磁盘上被物理删除。

**关键任务**:

1.  **项目初始化**: 创建标准的 VS Code 扩展项目结构，并在 `package.json` 中声明视图、命令和配置项 (需求 §3, §5)。
2.  **配置引导**: 实现启动检查逻辑，当 `issueManager.issueDir` 未设置时，在视图中显示引导信息和“立即配置”按钮 (需求 §2.8)。
3.  **实现“孤立问题”视图**:
    -   实现一个 `TreeDataProvider`，用于扫描 `issueManager.issueDir` 目录 (需求 §2.3)。
    -   解析每个 `.md` 文件获取其标题（优先使用 `#` 标题，后备为文件名）(需求 §0)。
    -   将扫描到的所有 `.md` 文件作为根节点，在 `孤立问题` 视图中以扁平列表展示。
4.  **实现“点击打开”**: 为视图项添加命令，实现在编辑器中打开对应文件的功能 (需求 §2.7)。
5.  **实现“创建问题”命令 (简化版)**:
    -   实现 `issueManager.createIssue` 命令（此时无需 LLM 智能功能）(需求 §3)。
    -   命令触发后，弹出一个输入框让用户输入问题标题。
    -   根据标题在 `issueManager.issueDir` 目录中创建一个新的、以时间戳命名的 `.md` 文件，并将标题作为一级标题写入文件 (需求 §2.1.2)。
    -   创建后，自动在编辑器中打开该文件。
6.  **实现实时刷新**: 使用 `FileSystemWatcher` 监听 `issueDir` 目录中文件的增、删、改，实现孤立问题视图的自动刷新 (需求 §2.3, §6.1)。
7.  **实现“删除问题”命令**:
    -   为 `孤立问题` 视图中的项添加“删除”上下文菜单命令 (需求 §2.3)。
    -   该命令会从磁盘上物理删除对应的 `.md` 文件。
    -   删除前，必须弹出一个确认对话框以防止误操作 (需求 §2.3)。

---

## 里程碑二：构建层级与组织能力 (Milestone 2: Building the Hierarchy)

**核心用户故事**: “作为一名用户，我希望能将我散乱的笔记组织成一个有意义的层级结构。我希望通过简单的拖拽，就能创建父子关系和同级关系，并将新笔记从‘收件箱’(孤立问题视图)中归类到总览树中。”

**验收场景 (Acceptance Scenarios)**:

- [ ] **场景1：从孤立到总览** - 我可以将一个或多个问题从 `孤立问题` 视图拖拽到 `问题总览` 视图中，并根据释放位置，将它们添加为顶层问题、子问题或同级问题。
- [ ] **场景2：内部结构调整** - 我可以在 `问题总览` 视图内部拖拽一个或多个节点，以重新排列它们的顺序或改变它们的父子关系。
- [ ] **场景3：解除关联** - 在 `问题总览` 视图中对一个节点使用“解除关联”命令后，该节点从树中消失，并重新出现在 `孤立问题` 视图中。源 `.md` 文件保留。
- [ ] **场景4：持久化** - 关闭并重新打开 VS Code 后，`问题总览` 视图的树状结构保持不变。
- [ ] **场景5：防止循环引用** - 当我尝试将一个父节点拖拽为其自身子孙节点时，操作被阻止，视图结构不发生改变。

**关键任务**:

1.  **实现 `tree.json` 数据模型**: 设计并实现用于持久化树状结构的数据读写逻辑 (需求 §4.2)。
2.  **实现“问题总览”视图**:
    -   基于 `tree.json` 的数据来渲染树状视图 (需求 §2.2)。
    -   为视图添加“新建子问题”和“新建顶层问题”的上下文菜单命令 (需求 §2.2)。
3.  **实现拖拽控制器 (`DragAndDropController`)**: 这是本阶段的核心任务 (需求 §2.5, §6.1)。
    -   处理从 `孤立问题` 和编辑器标签页到 `问题总览` 的拖拽。
    -   处理 `问题总览` 内部节点之间的拖拽。
    -   实现拖拽时的视觉反馈（高亮目标位置）。
4.  **实现“解除关联”命令**: 从 `tree.json` 中移除节点引用，并触发视图刷新 (需求 §2.2)。
5.  **实现健壮性**: 开发循环引用检查逻辑，在拖拽操作执行前进行预判断 (需求 §6.6)。

---

## 里程碑三：聚焦关键问题 (Milestone 3: Focusing on What Matters)

**核心用户故事**: “作为一名用户，我的任务列表可能很庞杂，我希望能标记出当前最重要的几个问题，并在一个专门的视图中追踪它们。这个视图应该只包含我关注的问题及其子任务，保持界面的清爽。同时，为了不丢失上下文，我希望能通过鼠标悬停快速查看某个任务的完整归属路径。”

**验收场景 (Acceptance Scenarios)**:

- [ ] **场景1：添加关注** - 在 `问题总览` 视图中对一个节点使用“添加到关注”后，`关注问题` 视图会刷新，并以顶层节点的形式展示该节点及其完整的后代子树。
- [ ] **场景2：上下文提示** - 当我将鼠标悬停在 `关注问题` 视图的任意一个节点上时，会出现一个工具提示（Tooltip），显示其在 `问题总览` 中的完整祖先路径（例如：`祖先 / 父`）。
- [ ] **场景3：移除关注** - 在 `关注问题` 视图中对一个被直接关注的节点使用“移除关注”后，该节点及其所有后代会从视图中消失。
- [ ] **场景4：结构同步** - 在 `关注问题` 视图中对节点进行任何结构调整（如拖拽、创建问题、解除关联），`问题总览` 视图会实时反映出完全相同的结构变化。
- [ ] **场景5：状态持久化** - 关闭并重新打开 VS Code 后，`关注问题` 视图中展示的内容保持不变。

**关键任务**:

1.  **实现 `focused.json` 数据模型**: 设计并实现用于存储关注节点 ID 列表的读写逻辑 (需求 §4.3)。
2.  **实现“关注问题”视图**: 
    -   实现“结构与状态分离”的渲染逻辑，在内存中根据 `tree.json` 和 `focused.json` 动态构建过滤后的树 (需求 §2.4, §6.2)。
    -   支持与“问题总览”一致的结构操作，包括创建问题、解除关联、拖拽等。
    -   “移除关注”操作仅对被直接关注的一级节点可用。
3.  **实现上下文菜单命令**: 开发 `issueManager.focusIssue` 和 `issueManager.removeFocus` 命令 (需求 §3, §2.2, §2.4)。
4.  **确保视图同步**: 保证对 `tree.json` 的修改能够同时触发 `问题总览` 和 `关注问题` 两个视图的刷新 (需求 §6.2)。

---

## 里程碑四：智能新建工作流 (Milestone 4: The Smart Create Workflow)

**核心用户故事**: “作为一名用户，当我灵光一闪时，我希望能用一个快捷键快速捕捉想法，而不必费心措辞或担心它是否已存在。我希望系统能帮我优化标题、检查重复，并让我一步完成‘创建新笔记’或‘打开相关笔记’的决策。”

**验收场景 (Acceptance Scenarios)**:

- [ ] **场景1：触发与输入** - 执行 `issueManager.createIssue` 命令后，出现一个 Quick Pick 输入框，提示我输入问题。
- [ ] **场景2：即时创建** - 输入问题后，Quick Pick 列表立即出现，第一项是我的原始输入，我可以选择它直接创建新笔记，无需等待 AI 返回。
- [ ] **场景3：智能推荐** - 在我输入后，Quick Pick 列表显示加载状态；短暂等待后，列表动态更新，同时展示 AI 优化的标题建议和找到的相似笔记。
- [ ] **场景4：执行创建** - 当我从 Quick Pick 列表中选择一个“[创建新笔记]”选项后，一个新的 `.md` 文件被创建，其一级标题是我选择的文本，文件被自动打开，并出现在 `孤立问题` 视图中。
- [ ] **场景5：执行打开** - 当我从 Quick Pick 列表中选择一个“[打开已有笔记]”选项后，对应的已有 `.md` 文件被直接打开。

**关键任务**:

1.  **实现统一选择界面 (`Quick Pick`)**: 使用 `vscode.window.createQuickPick` API，并实现其 `busy` 状态和 `items` 的动态更新 (需求 §2.1.2, §6.1)。
2.  **LLM 集成**: 设计一个 `LLMService`，并设计高效的复合任务 Prompt (需求 §2.1.2, §6.3)。
3.  **内容检索**: 开发一个函数，用于在调用 LLM 前，快速收集工作区内所有笔记的标题或摘要作为上下文 (需求 §6.3)。
4.  **实现命令逻辑**: 将以上部分串联起来，完成 `issueManager.createIssue` 命令的完整流程 (需求 §2.1, §3)。

---

## 里程碑五：互操作性与最终打磨 (Milestone 5: Interoperability & Polish)

**核心用户故事**: “作为一名用户，我希望插件能与我的写作流程无缝集成，例如能轻松地在笔记间创建链接。同时，我希望插件是稳定可靠的，即使我误操作（如删除了一个文件），它也不会崩溃，而是能给我清晰的提示。”

**验收场景 (Acceptance Scenarios)**:

- [ ] **场景1：生成链接** - 从任意问题视图中拖拽一个节点到 Markdown 编辑器中，会在光标位置插入一个格式正确的 Markdown 链接。
- [ ] **场景2：视图联动** - 当我在编辑器中激活一个属于 `issueDir` 的 `.md` 文件时，`问题总览` 等视图会自动展开并高亮对应的节点。
- [ ] **场景3：处理文件丢失** - 当一个被 `tree.json` 引用的文件在磁盘上被删除后，视图中对应的节点会显示一个“文件未找到”的警告状态，并且允许用户“解除关联”这个无效引用。
- [ ] **场景4.1：处理数据损坏** - 当 `tree.json` 等数据文件损坏（如 JSON 格式错误）时，插件能够正常启动，并向用户发出通知。
- [ ] **场景4.2：安全恢复** - 在数据文件损坏的情况下，插件会备份损坏文件，并以安全模式启动，将 `issueDir` 下的所有 `.md` 文件加载到 `孤立问题` 视图中。

**关键任务**:

1.  **实现“拖拽到编辑器”**: 扩展拖拽逻辑，处理到 `text/plain` 编辑器的拖放事件 (需求 §2.6)。
2.  **实现“在视图中高亮”**: 监听 VS Code 的 `window.onDidChangeActiveTextEditor` 事件，并调用视图的 `reveal` 方法 (需求 §2.7)。
3.  **健壮性与数据恢复**: 
    -   实现对丢失文件的优雅处理 (需求 §6.6)。
    -   实现启动时的数据校验和损坏文件恢复机制 (需求 §4.5)。
4.  **性能优化**: 实现标题缓存 (`titleCache.json`)，并对高频事件进行防抖处理 (需求 §4.4, §6.5)。
5.  **最终测试与文档**: 编写各类测试，完善用户文档，为发布做准备。
