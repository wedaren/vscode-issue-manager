# 问题管理插件 (Issue Manager) - 用户故事驱动的实施规划

本文档将插件的开发过程分解为五个核心里程碑，每个里程碑都围绕一个或多个核心用户故事展开。这种方式旨在确保每个开发阶段都交付明确的用户价值，并方便进行功能验收。

---

## 里程碑一：首次运行体验与基本知识库 (Milestone 1: The First Run Experience)

**核心用户故事**: “作为一名新用户，我希望能轻松完成插件的初始配置。配置成功后，我希望立即看到一个我指定目录下的所有笔记的列表，并且可以点击列表中的任何一项来打开对应的文件。”

**验收标准**:

- [ ] 首次启动插件时，如果未配置“问题目录”，视图区域会清晰地提示我进行配置，并提供一个按钮让我一键打开设置文件。
- [ ] 当我设置好 `issueManager.issueDir` 路径并保存后，`孤立问题` 视图会自动刷新，并以列表形式展示出该目录下的所有 `.md` 文件。
- [ ] 我可以点击 `孤立问题` 视图中的任意一个文件，VS Code 会在编辑器中打开它。
- [ ] 此时，`问题总览` 和 `关注问题` 视图可以是空的，或显示引导信息。

**关键任务**:

1.  **项目初始化**: 创建标准的 VS Code 扩展项目结构，并在 `package.json` 中声明视图和配置项。
2.  **配置引导**: 实现启动检查逻辑，当 `issueManager.issueDir` 未设置时，在视图中显示引导信息和“立即配置”按钮。
3.  **实现“孤立问题”视图 (只读)**:
    -   实现一个 `TreeDataProvider`，用于扫描 `issueManager.issueDir` 目录。
    -   将扫描到的所有 `.md` 文件作为根节点，在 `孤立问题` 视图中以扁平列表展示。
4.  **实现“点击打开”**: 为视图项添加命令，实现在编辑器中打开对应文件的功能。

---

## 里程碑二：构建层级与组织能力 (Milestone 2: Building the Hierarchy)

**核心用户故事**: “作为一名用户，我希望能将我散乱的笔记组织成一个有意义的层级结构。我希望通过简单的拖拽，就能创建父子关系和同级关系，并将新笔记从‘收件箱’(孤立问题视图)中归类到总览树中。”

**验收标准**:

- [ ] 我可以将一个笔记从 `孤立问题` 视图拖拽到 `问题总览` 视图的空白区域，使其成为一个顶级问题。
- [ ] 我可以将一个笔记拖拽到 `问题总览` 视图中另一个笔记的上方，使其成为后者的子笔记。
- [ ] 我可以将一个笔记拖拽到两个笔记之间的缝隙处，使其成为它们的同级笔记。
- [ ] 我可以拖拽 `问题总览` 视图中已有的笔记，来重新组织它们的顺序和层级。
- [ ] 我可以右键点击 `问题总览` 中的一个笔记，选择“解除关联”，该笔记会从树中消失，并重新出现在 `孤立问题` 视图中，但源文件不会被删除。
- [ ] 我无法将一个父节点拖拽到它的子节点下（防止循环引用）。
- [ ] 所有的结构变化（层级、顺序）在重启 VS Code 后都能够保持原样。

**关键任务**:

1.  **实现 `tree.json` 数据模型**: 设计并实现用于持久化树状结构的数据读写逻辑。
2.  **实现“问题总览”视图**: 基于 `tree.json` 的数据来渲染树状视图。
3.  **实现拖拽控制器 (`DragAndDropController`)**: 这是本阶段的核心任务。
    -   处理从 `孤立问题` 到 `问题总览` 的拖拽。
    -   处理 `问题总览` 内部节点之间的拖拽。
    -   实现拖拽时的视觉反馈（高亮目标位置）。
4.  **实现“解除关联”命令**: 从 `tree.json` 中移除节点引用，并触发视图刷新。
5.  **实现健壮性**: 开发循环引用检查逻辑，在拖拽操作执行前进行预判断。

---

## 里程碑三：聚焦关键问题 (Milestone 3: Focusing on What Matters)

**核心用户故事**: “作为一名用户，我的任务列表可能很庞杂，我希望能标记出当前最重要的几个问题，并在一个专门的视图中追踪它们。这个视图应该只包含我关注的问题，但同时也要展示它们完整的上下文（即所有的父级和子级），以便我能理解它们的全貌。”

**验收标准**:

- [ ] 我可以在 `问题总览` 视图中右键点击任何一个问题，选择“添加到关注”。
- [ ] 操作后，这个问题会出现在 `关注问题` 视图中。
- [ ] `关注问题` 视图会同时显示该问题的所有父级节点（一直到根节点）和所有子级节点（完整的子树）。
- [ ] 如果我关注了一个子节点，它的父节点即使未被直接标记为“关注”，也会作为结构的一部分出现在 `关注问题` 视图中。
- [ ] 我可以在 `关注问题` 视图中右键点击一个问题，选择“移除关注”。如果该问题没有子问题被关注，它会从这个视图中消失。
- [ ] 在 `关注问题` 视图中进行的任何拖拽操作（如修改层级），其结果会同步体现在 `问题总览` 视图中。

**关键任务**:

1.  **实现 `focused.json` 数据模型**: 设计并实现用于存储关注节点 ID 列表的读写逻辑。
2.  **实现“关注问题”视图**: 
    -   实现“结构与状态分离”的渲染逻辑，在内存中根据 `tree.json` 和 `focused.json` 动态构建过滤后的树。
3.  **实现上下文菜单命令**: 开发 `issueManager.focusIssue` 和 `issueManager.removeFocus` 命令。
4.  **确保视图同步**: 保证对 `tree.json` 的修改能够同时触发 `问题总览` 和 `关注问题` 两个视图的刷新。

---

## 里程碑四：智能新建工作流 (Milestone 4: The Smart Create Workflow)

**核心用户故事**: “作为一名用户，当我灵光一闪时，我希望能用一个快捷键快速捕捉想法，而不必费心措辞或担心它是否已存在。我希望系统能帮我优化标题、检查重复，并让我一步完成‘创建新笔记’或‘打开相关笔记’的决策。”

**验收标准**:

- [ ] 我可以使用一个命令（或快捷键）触发 `issueManager.createIssue`。
- [ ] 系统会弹出一个输入框让我输入我的想法，例如“vscode 改颜色”。
- [ ] 在我输入后，会弹出一个加载中的列表，列表第一项是我输入的原文，我可以立即选择它来创建笔记。
- [ ] 短暂等待后，列表会自动更新，下方会出现几项由 AI 优化的标题建议（如“如何修改 VS Code 的主题颜色？”）和几个内容最相关的已有笔记。
- [ ] 我选择一个“创建”项，系统会用该标题创建一个新的 `.md` 文件并打开它，这个新文件会出现在 `孤立问题` 视图中。
- [ ] 我选择一个“打开”项，系统会直接打开那个已有的笔记文件。

**关键任务**:

1.  **实现统一选择界面 (`Quick Pick`)**: 使用 `vscode.window.createQuickPick` API，并实现其 `busy` 状态和 `items` 的动态更新。
2.  **LLM 集成**: 设计一个 `LLMService`，并设计高效的复合任务 Prompt。
3.  **内容检索**: 开发一个函数，用于在调用 LLM 前，快速收集工作区内所有笔记的标题或摘要作为上下文。
4.  **实现命令逻辑**: 将以上部分串联起来，完成 `issueManager.createIssue` 命令的完整流程。

---

## 里程碑五：互操作性与最终打磨 (Milestone 5: Interoperability & Polish)

**核心用户故事**: “作为一名用户，我希望插件能与我的写作流程无缝集成，例如能轻松地在笔记间创建链接。同时，我希望插件是稳定可靠的，即使我误操作（如删除了一个文件），它也不会崩溃，而是能给我清晰的提示。”

**验收标准**:

- [ ] 我可以从任意一个问题视图中，将一个笔记拖拽到打开的 Markdown 编辑器中，光标处会自动插入一个指向该笔记的 Markdown 链接。
- [ ] 当我在编辑器中打开一个笔记文件时，`问题总览` 等视图会自动定位并高亮这个文件对应的节点。
- [ ] 如果我手动删除了一个被 `问题总览` 引用的 `.md` 文件，视图中的对应节点不会导致崩溃，而是会显示一个“文件未找到”的特殊图标。
- [ ] 如果插件的核心数据文件（如 `tree.json`）意外损坏，插件在下次启动时能检测到问题，备份损坏文件，并以安全模式启动（将所有笔记都视为孤立问题），保证我的源文件万无一失。

**关键任务**:

1.  **实现“拖拽到编辑器”**: 扩展拖拽逻辑，处理到 `text/plain` 编辑器的拖放事件。
2.  **实现“在视图中高亮”**: 监听 VS Code 的 `window.onDidChangeActiveTextEditor` 事件，并调用视图的 `reveal` 方法。
3.  **健壮性与数据恢复**: 
    -   实现对丢失文件的优雅处理。
    -   实现启动时的数据校验和损坏文件恢复机制。
4.  **性能优化**: 实现标题缓存 (`titleCache.json`)，并对高频事件进行防抖处理。
5.  **最终测试与文档**: 编写各类测试，完善用户文档，为发布做准备。
