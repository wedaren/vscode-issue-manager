# 问题管理插件需求文档

## 0. 名词统一 (Terminology)

为确保项目内部沟通、代码实现和文档的一致性，特此统一本项目中使用的核心名词及其定义。

### 核心概念

- **插件名称 (Plugin Name)**: **问题管理插件 (Issue Manager)**。本 VS Code 扩展的正式名称。
- **问题 (Issue)**: 插件管理的基本单元。每个“问题”在物理上对应“问题目录”中的一个独立的 Markdown (`.md`) 文件。
- **问题标题 (Issue Title)**: “问题”在界面中显示的名称。严格采用其 `.md` 文件中的第一个一级标题 (`#`)。若文件中无一级标题，则使用文件名（不含扩展名）作为后备标题。

### 核心目录

- **问题目录 (Issue Directory)**: 用户通过配置项 `issueManager.issueDir` 指定的一个**绝对路径**。它是存放所有“问题”文件 (`.md`) 的根目录。
- **数据目录 (Data Directory)**: 位于“问题目录”下的一个隐藏子目录 `.issueManager/`。它用于存放所有插件生成的元数据（如 `tree.json`, `focused.json`），确保整个知识库的自包含性和可移植性。

### 核心视图

- **问题总览 (Issue Overview)**: 主视图。以树状结构展示所有“问题”及其层级和关联关系。这是组织和管理问题的主要场所。
- **孤立问题 (Isolated Issues)**: 收件箱视图。以扁平列表形式展示所有存在于“问题目录”中，但尚未在“问题总览”视图中建立任何关联的“问题”。
- **关注问题 (Focused Issues)**: 过滤视图。以树状结构展示被用户标记为“关注”的“问题”及其完整的上下文（所有父级和子级节点）。

### 数据与操作

- **节点 (Node)**: `tree.json` 数据结构中的一个对象，代表对某个“问题”文件的一次**引用**。一个“问题”文件可以在“问题总览”树中被多次引用，每次引用都是一个具有唯一 `id` 的独立“节点”。
- **关联 (Association)**: 在视图中建立“节点”之间关系（如父子、同级）的操作，通常通过拖拽完成。此操作会修改 `tree.json` 文件。
- **解除关联 (Disassociation)**: 从“问题总览”树中移除一个“节点”引用的操作。此操作仅影响视图结构（修改 `tree.json`），**不会**删除物理上的 `.md` 文件。
  - **无子节点时**：直接解除关联，无需任何提示。
  - **有子节点（即存在子树）时**：操作前弹出确认提示：“该节点下包含子问题，解除关联将一并移除其所有子节点。是否继续？”用户确认后才执行解除。
- **添加/移除关注 (Focus/Unfocus)**: 将一个“问题”在“关注问题”视图中添加或移除的操作。此操作仅影响 `focused.json` 文件，不改变 `tree.json` 中的核心结构。

---

## 1. 概述

本插件旨在为 VS Code 用户提供一个强大的、集成的、基于视图的问题管理系统。它以本地 Markdown 文件作为数据源，帮助用户高效地创建问题、组织问题、建立问题间的层级和关联关系，并通过一个可定制的“关注”视图来追踪重要问题。

## 2. 核心功能与视图

插件的核心功能围绕着一个智能创建流程和三个核心视图展开。

### 2.1. 智能新建问题

这是插件最核心的入口功能，旨在通过 LLM 赋能，提供一个从想法捕捉到知识入库的无缝体验。

#### 2.1.1. 用户故事

- 作为一名用户，我希望能快速记录一个想法，而不必担心措辞是否完美或知识库中是否已有相关内容。
- 作为一名用户，我希望系统能帮我把随意的想法（如“怎么改 vscode 颜色”）优化成清晰的标题（如“如何修改 VS Code 的主题颜色？”）。
- 作为一名用户，我希望在创建新笔记前，能立即看到可能相关的已有笔记，避免信息孤岛和重复劳动。
- 作为一名用户，我希望整个过程是流畅的，最好在一个界面完成所有选择，而不是分好几步。

#### 2.1.2. 核心工作流程

1. **触发 (Trigger):**
   - 用户通过快捷键 (例如 `Cmd+Shift+N`) 或从命令面板运行 `issueManager.createIssue` 命令。

2. **输入问题 (Input Question):**
   - VS Code 顶部出现一个 Quick Pick 输入框，提示用户输入问题 (Placeholder text: "请输入您的问题...")。
   - 用户输入问题后按 `Enter` 键确认。

3. **统一智能处理 (Unified Intelligence Processing):**
   - 插件将用户的原始输入文本发送给 LLM。
   - LLM 执行一个**复合任务 (Compound Task)**，其 Prompt 经过精心设计，要求模型**在一次调用中同时返回两类信息**：
     - **A. 问题优化建议 (Optimized Phrasings):** 3-4个对原始输入的重述、修正或优化后的版本。
     - **B. 相似笔记检索 (Similar Notes):** 在用户知识库（工作区内的 `.md` 文件）中检索出的最多5个语义最相关的已有笔记。

4. **统一选择界面 (Unified Quick Pick):**
   - 系统**立即**弹出一个 `Quick Pick` 列表，并显示加载状态 (`busy = true`)。
   - 列表的初始内容是用户的原始输入，允许用户不等待 LLM 直接创建。
   - 当 LLM 返回结果后，列表动态更新，最终呈现一个合并后的选项清单，结构如下：
     - `[创建新笔记] {用户原始输入}`
     - `[创建新笔记] {LLM 优化建议 1}`
     - `[创建新笔记] {LLM 优化建议 2}`
     - --- 分隔线 ---
     - `[打开已有笔记] {相似笔记 1 的标题}`
     - `[打开已有笔记] {相似笔记 2 的标题}`
     - ...

5. **执行操作 (Action):**
   - **选择 `[创建新笔记]`:**
     - 使用用户选定的文本作为一级标题。
     - 以 `YYYYMMDD-HHmmss.md` 格式的时间戳创建新文件。
     - 打开新文件并定位光标，以便用户立即开始写作。
   - **选择 `[打开已有笔记]`:**
     - 直接打开对应的 Markdown 文件。
   - **按 `Esc` 取消:**
     - 流程中断，不执行任何操作。

### 2.2. 问题总览 (Issue Overview)

此视图是问题的主要管理界面，以树状结构展示所有问题及其关系。

- **功能**:
  - **树状展示**: 清晰地展示问题之间的父子、依赖等层级关系。
  - **创建问题**: 可以通过视图顶部的 `+` 按钮或右键菜单创建新的顶层问题或子问题。
  - **解除关联**: 右键点击问题，可以解除其在树中的关联。此操作仅从视图中移除节点引用，不删除物理文件。若节点无子问题，则直接解除；若有子问题，则在操作前弹出确认提示。
  - **关联问题**: 支持通过拖拽操作灵活地组织问题。详细规则请参见 [2.5. 问题关联与结构操作](#25-问题关联与结构操作)。
  - **多重引用**: 同一问题（Markdown 文件）可在树中多处引用，实现灵灵活分类。
  - **添加到关注**: 右键点击问题，提供 "添加到关注" 选项，可将问题添加到 `关注问题` 视图中进行追踪。
  - **批量操作**: 支持通过多选对问题进行批量操作（如批量解除关联、移动、添加至关注等）。

### 2.3. 孤立问题 (Isolated Issues)

此视图作为新问题的收件箱，所有被创建但尚未建立任何关联的问题都会在这里列出。

- **功能**:
  - **自动发现**: 自动扫描配置的笔记路径，找出所有未在 `问题总览` 树中引用的 `.md` 文件（孤立问题），并以列表形式展示。
  - **列表展示**: 以扁平列表形式展示所有孤立的问题。
  - **排序方式**: 列表中的问题默认按**文件创建时间倒序**排列，确保最新的问题显示在最顶部，方便用户快速处理新条目。
  - **实时刷新**: 列表实时刷新，响应工作区文件的增、删、改变化。
  - **问题来源**: 通过命令面板 (Command Palette) 创建的新问题将首先出现在此视图中。
  - **问题归类**:
    - **支持**: 从本视图拖拽问题到 `问题总览` 或 `关注问题` 视图中，可以为其建立父子关系，使其不再孤立。此操作会更新 `tree.json` 并将问题从本视图移除。详细规则请参见 [2.5. 问题关联与结构操作](#25-问题关联与结构操作)。
    - **不支持**: `孤立问题` 视图是一个只进不出的“收件箱”。因此，**不支持**从 `问题总览` 或 `关注问题` 视图向本视图进行任何拖拽操作。
  - **删除问题**:
    - **功能**: 右键点击一个或多个孤立问题，提供“删除”选项。
    - **操作**: 执行此操作将从磁盘上**物理删除**对应的 `.md` 文件。
    - **确认**: 为防止误操作，执行删除前**必须**弹出一个确认对话框，明确告知用户文件将被永久删除。

### 2.4. 关注问题 (Focused Issues)

此视图是“问题总览”视图的一个交互式、过滤后的镜像，旨在帮助用户追踪核心任务。其交互功能与“问题总览”视图基本保持一致。

- **功能**:
  - **聚焦展示**: 以树状结构呈现所有被标记为“关注”的问题及其所有子级节点。与“问题总览”不同，此视图**不会**直接展示其祖先节点，从而保持列表的简洁性。
  - **上下文悬停提示**: 为了在不牺牲简洁性的前提下提供上下文，当用户鼠标悬停在任一问题节点上时，会显示一个工具提示（Tooltip），内容为该节点的完整父级路径（例如 `/ 祖先问题 / 父问题`）。
  - **结构同步与操作**: 本视图中的所有结构操作（如创建、删除、关联）与“问题总览”完全同步，并遵循相同的交互规则。详细规则请参见 [2.5. 问题关联与结构操作](#25-问题关联与结构操作)。
  - **创建问题**: 可以通过右键菜单创建新的顶层问题或子问题，操作方式与“问题总览”一致。
  - **解除关联**: 支持右键点击问题节点，解除其在关注视图中的结构关联，操作逻辑与“问题总览”一致（仅影响结构，不删除文件）。
  - **移除关注**: 右键点击问题，提供“移除关注”选项。此选项**仅对被直接设为关注的一级节点可用**，执行后会将其从本视图中移除（不影响其在“问题总览”中的存在）。

### 2.5. 问题关联与结构操作 (Issue Association and Structural Operations)

这是 `问题总览` 和 `关注问题` 视图共享的核心交互功能，主要通过拖拽 (Drag and Drop) 实现。

- **拖拽来源 (Drag Sources)**:
  - **从各视图拖拽**:
    - `问题总览` 与 `关注问题`: 从这两个视图中拖拽一个或多个已有问题节点。
    - `孤立问题`: 从此视图中拖拽一个或多个孤立问题，以将其纳入结构。
  - **从编辑器拖拽**:
    - 从 **编辑器标签页** 拖拽一个 `.md` 文件。

- **拖拽目标与行为 (Drop Targets and Behaviors)**:
  - **拖拽到一个问题上**: 将被拖拽的问题（或文件）添加为目标问题的**子问题**。
  - **拖拽到两个问题的间隙**: 将被拖拽的问题（或文件）作为同级，插入到间隙对应位置。
  - **拖拽到视图的空白区域**: 将被拖拽的问题（或文件）添加为**顶层根问题**。

- **全局约束 (Global Constraints)**:
  - **文件类型**: 所有从外部（如编辑器）拖入的项目必须是 `.md` 文件。
  - **文件路径**: 为了维护知识库的完整性，从编辑器拖入的 `.md` 文件，其路径**必须**位于用户配置的 `issueManager.issueDir` 目录之内。插件将拒绝关联此目录之外的文件。

### 2.6. 拖拽到编辑器生成链接 (Drag to Editor for Link)

- 允许用户从 `问题总览`、`孤立问题` 或 `关注问题` 视图中拖拽任意问题项到文本编辑器中。
  - **行为**: 如果目标编辑器是 Markdown 文件，并且其自身也位于配置好的“问题目录” (`issueManager.issueDir`) 下，则在光标位置插入一个指向该问题的 Markdown 链接 (例如 `[问题标题](<link-to-issue>)`)。

### 2.7. 视图与编辑器的双向联动 (View and Editor Sync)

- **从视图到编辑器 (Reveal in Editor)**: 在任意问题视图 (`问题总览`, `孤立问题`, `关注问题`) 中单击问题项，应在编辑器中打开对应的 Markdown 文件。
- **从编辑器到视图 (Reveal in Tree View)**: 当用户在编辑器中打开并激活一个属于“问题目录”的 Markdown 文件时，`问题总览`, `孤立问题` 和 `关注问题` 视图应自动展开并高亮显示对应的文件节点。

### 2.8. 启动与配置引导 (Onboarding)

- **前置条件**: 插件的核心功能依赖于用户设置“问题目录” (`issueManager.issueDir`)。
- **启动检查与上下文设置**: 
  - 插件激活时，会检查 `issueManager.issueDir` 配置是否存在。
  - 同时，它会通过 `vscode.commands.executeCommand('setContext', 'issueManager.isDirConfigured', ...)` 设置一个全局的布尔值上下文。这个上下文的值会根据配置是否存在而实时更新（例如，在启动时和配置变更时）。
- **未配置状态下的视图 (View Welcome Content)**:
  - 如果 `issueManager.issueDir` 未设置（即 `issueManager.isDirConfigured` 上下文为 `false`），所有三个核心视图 (`问题总览`, `孤立问题`, `关注问题`) 将不会加载问题数据。
  - 相反，每个视图会利用 VS Code 的 `viewsWelcome` 贡献点，显示一段引导信息，例如：“请先配置问题目录以激活插件功能。”
  - 这段信息中会包含一个可点击的、命令驱动的链接，如“**[立即配置]**”，它直接链接到打开设置的命令。
- **引导操作**:
  - 点击“立即配置”链接后，将自动打开当前工作区的 `settings.json` 文件，并聚焦到 `issueManager.issueDir` 配置项，方便用户快速填写。
  - 一旦用户保存了有效的目录配置，`issueManager.isDirConfigured` 上下文会自动变为 `true`，`viewsWelcome` 内容随之消失，所有视图和命令将自动激活并正常工作。

## 3. 命令 (Commands)

插件应在命令面板中注册以下命令：

- `issueManager.createIssue`: 通过一个由 LLM 赋能的智能流程快速创建新问题。详细工作流程请参见“核心功能与视图”一节。新创建的问题将出现在 `孤立问题` 视图中。
- `issueManager.focusIssue`: (在 `问题总览` 视图中通过右键菜单触发) 将选中的问题添加到 `关注问题` 视图中。
- `issueManager.removeFocus`: (在 `关注问题` 视图中通过右键菜单触发) 将选中的问题从 `关注问题` 视图中移除。

## 4. 数据模型与存储

为了实现数据的可移植性和自包含性，所有与本插件相关的数据文件（视图结构、缓存等）都将存储在用户配置的“问题目录”下的一个隐藏子目录 `.issueManager/` 中。

### 4.1. 数据存放核心注意事项

- **统一存放位置**: 所有数据文件，包括 `tree.json` 和 `titleCache.json`，都将被存放在 `<issueDir>/.issueManager/` 目录下。这使得整个知识库（包含源文件和结构数据）可以被轻松地复制、移动或通过版本控制同步。
- **自动创建与管理**:
  - 当用户首次配置 `issueManager.issueDir` 后，插件会自动在后台创建 `.issueManager` 子目录。
  - 为方便版本控制，插件会在 `.issueManager/` 目录中自动创建一个 `.gitignore` 文件，内容为 `titleCache.json`，以确保缓存文件不会被意外提交。
- **新版存储方案**:
  - 本版本采用全新的数据存储方案，不再支持从旧版本（如存储在 `.vscode/` 目录下）自动迁移数据。这是一个更稳定、更可移植的全新开始。
- **权限检查**: 在尝试写入任何数据前，插件会检查对 `.issueManager/` 目录是否拥有写权限，并在权限不足时向用户发出明确提示。
- **处理问题目录变更**: 当插件检测到 `issueManager.issueDir` 的配置发生变化时，它将执行以下检查：
  - **检查新目录**: 插件会立即检查新的 `issueManager.issueDir` 路径下是否存在 `.issueManager/` 子目录。
  - **找到数据**: 如果 `.issueManager/` 存在，插件会加载其中的数据（`tree.json`, `focused.json` 等），并无缝衔接工作。这被视为用户已将整个问题库（源文件和 `.issueManager` 目录）移动到了新位置。
  - **未找到数据**: 如果 `.issueManager/` **不**存在，插件会将其视为一个全新的、空的知识库。它将自动在后台创建 `.issueManager` 子目录及必要的初始文件（如空的 `tree.json`），为用户提供一个即时可用的新环境。

### 4.2. 问题树结构数据 (`tree.json`)

- **数据存储**: 所有问题的**视图结构**（如层级、折叠状态等）将存储在 `<issueDir>/.issueManager/tree.json` 文件中。
- **用途**: 持久化 `问题总览` 视图的树状结构。
- **数据结构**:

    ```json
    {
      "version": "1.0.0",
      "lastModified": "2025-06-18T19:16:51.000Z",
      "rootNodes": [
        {
          "id": "node-uuid-1",
          "filePath": "/path/to/note-as-folder.md",
          "expanded": true,
          "children": [
            {
              "id": "node-uuid-2",
              "filePath": "/path/to/note.md",
              "children": []
            },
            {
              "id": "node-uuid-3",
              "filePath": "/path/to/another-note.md",
              "children": []
            }
          ]
        }
      ]
    }
    ```

- **节点属性说明**:
  - **id**: 唯一标识符 (UUID)。
  - **filePath**: 问题的 markdown 文件在磁盘上的**相对路径**（相对于 `issueDir` 目录）。这种设计确保了项目结构的内部一致性。如果整个问题目录被移动，用户**必须**在 VS Code 设置中更新 `issueManager.issueDir` 的绝对路径，但 `tree.json` 文件本身无需修改。
  - 如果文件在 `issueDir` 内部，路径是直接的相对路径，例如：`issues/issue-172839.md`。
  - 如果文件在 `issueDir` 外部，路径会包含 `../` 来向上导航，例如：`../../docs/related-note.md`。
  - 插件在加载时，需要将这个相对路径与 `issueManager.issueDir` 的绝对路径结合，来解析出文件的最终绝对路径。
- **children**: 子问题节点的数组，递归地定义了树的层级关系。

#### 示例 `tree.json`

```json
{
  "version": "1.0.0",
  "lastModified": "2025-06-18T19:16:51.000Z",
  "rootNodes": [
    {
      "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
      "filePath": "issues/issue-1.md",
      "expanded": true,
      "children": [
        {
          "id": "b2c3d4e5-f6a7-8901-2345-67890abcdef0",
          "filePath": "issues/issue-2.md",
          "children": []
        }
      ]
    }
  ]
}
```

#### 4.3 focused.json 数据结构

- **数据存储**: 所有被标记为“关注”的**节点 ID** 列表将存储在 `<issueDir>/.issueManager/focused.json` 文件中。
- **用途**: 持久化 `关注问题` 视图的状态。
- **数据结构**:

    ```json
    {
      "version": "1.0.0",
      "focusList": [
        "a1b2c3d4-e5f6-7890-1234-567890abcdef"
      ]
    }
    ```

- **属性说明**:
  - **version**: 数据结构版本。
  - **focusList**: 被关注问题的**节点 ID (`uuid`)** 列表。这些 ID 与 `tree.json` 中定义的节点 `id` 相对应。

#### 示例 `focused.json`

```json
{
  "version": "1.0.0",
  "focusList": [
    "a1b2c3d4-e5f6-7890-1234-567890abcdef"
  ]
}
```

#### 4.4 titleCache.json 数据结构

为了在不读取每个文件内容的情况下快速显示问题的标题，插件维护一个标题缓存。

- **文件结构**: 一个简单的 JSON 对象，将文件的**相对路径**（相对于 `issueDir` 目录）映射到其标题。
- **更新时机**:
  - 当一个问题被创建或标题被修改时，此缓存会同步更新。
  - 插件启动时，可以校验缓存的有效性。

#### 示例 `titleCache.json`

```json
{
  "issues/issue-1.md": "Root Issue",
  "issues/issue-2.md": "Sub Issue 1"
}
```

### 4.5. 数据校验与健壮性 (Data Validation and Robustness)

为防止用户手动编辑 `tree.json` 等数据文件时可能引入的错误，插件在加载时会执行严格的数据校验流程，以确保系统的健壮性。

- **JSON Schema 验证**:
  - 插件将为 `.issueManager/` 目录下的核心数据文件（如 `tree.json`, `focused.json`）提供 JSON Schema。
  - 当用户在 VS Code 中直接打开这些 JSON 文件时，可以获得实时语法检查、自动补全和属性说明，从而极大地降低手动编辑出错的概率。

- **启动时完整性检查**:
  - 每次加载数据时，除了基本的 JSON 语法解析，插件还会在内存中执行一系列完整性检查：
  1. **文件引用校验**: 遍历 `tree.json` 中的所有节点，检查每个 `filePath` 指向的文件是否真实存在于磁盘上。对于不存在的文件，将按 [6.6. 健壮性](#66-健壮性) 中“处理丢失文件”的策略进行处理。
  2. **ID 唯一性与一致性**: 确保 `tree.json` 内的所有节点 `id` 都是唯一的。同时，校验 `focused.json` 中的每一个 `id` 都能在 `tree.json` 中找到对应的节点。无效的 `id` 将被静默忽略。
  3. **循环引用检测**: 在构建树状结构时，检测是否存在循环引用（例如，一个节点是自身的祖先）。如果检测到循环，将断开循环链接并记录警告，防止无限递归。

- **损坏文件恢复机制**:
  - 如果在上述任何一个校验环节（包括 JSON 语法解析）失败，插件会认为该数据文件已损坏。
  - 此时，插件会：
  1. 向用户显示一条明确的错误通知，说明哪个文件已损坏，无法加载。
  2. 将损坏的文件备份（例如，重命名为 `tree.json.bak`）。
  3. 启动**安全恢复模式**：忽略损坏的结构文件，将 `issueDir` 目录下的所有 `.md` 文件全部加载到“孤立问题”视图中。
  - 这种机制确保了即使结构文件损坏，用户的核心笔记内容也绝不会丢失，并且可以方便地重新组织和恢复其结构。

## 5. 配置项

用户可以通过 VS Code 的 `settings.json` 文件对插件进行配置。

- **`issueManager.issueDir`**: (字符串) **必须是绝对路径**。指定一个本地文件系统上的目录，作为存放所有新建问题文件的“问题目录”。例如: `"/Users/user/Documents/MyNotes"`。
- **`issueManager.createIssue.enableIntelligence`**: (布尔值) 启用/禁用创建问题时的 LLM 增强功能。
- **`issueManager.createIssue.similarResultsCount`**: (数字) 配置返回的相似问题数量。
- **`issueManager.createIssue.optimizedPhrasingsCount`**: (数字) 配置 LLM 生成的优化建议数量。

## 6. 总体技术要点

### 6.1. VS Code API

- **视图实现**: 实现 `TreeDataProvider` 接口来提供 `问题总览`、`孤立问题` 和 `关注问题` 三个视图的数据。
- **拖拽处理**: 实现 `DragAndDropController` 来处理视图内部以及视图与编辑器之间的拖拽操作。
- **文件监听**: 使用 `FileSystemWatcher` 监听工作区内 `.md` 文件的增、删、改，以实时刷新视图和缓存。
- **智能输入框**: 充分利用 `vscode.window.createQuickPick` 的高级功能，包括设置 `busy` 状态和动态更新 `items` 列表，以实现异步加载的统一选择界面。

### 6.2. “关注视图”实现方案

采用**“结构与状态分离”**的设计模型，将问题的核心层级关系与用户的“关注”状态分别存储，以实现高性能渲染和清晰的逻辑。

- **数据模型**:
  - **`tree.json` (结构文件)**: 作为单一的、权威的结构数据源，存储所有问题的层级关系。
  - **`focused.json` (状态文件)**: 仅记录被标记为“关注”的问题ID列表，不包含任何层级信息。

- **视图渲染逻辑**:
  1. **数据读取**: 同时加载 `tree.json` 的完整结构树和 `focused.json` 的关注ID列表。
  2. **节点过滤**: `FocusedIssuesProvider` 遍历 `tree.json`，找出所有在 `focused.json` 列表中被引用的节点。
  3. **渲染呈现**: 将找到的节点（及其完整的后代子树）作为根节点，渲染到“关注问题”视图中。
  4. **上下文提示**: 在渲染每个列表项时 (`getTreeItem`)，为其动态生成并附加一个 `tooltip`，该 `tooltip` 通过向上查找节点的祖先链来实时生成路径字符串。

- **双向同步机制**:
  - **结构性变更 (如拖拽)**: 无论在哪个视图操作，都直接修改底层的 `tree.json`，然后通知**两个**视图刷新。
  - **状态性变更 (添加/移除关注)**: 仅修改 `focused.json`，然后通知“关注视图”刷新。

### 6.3. LLM 集成与 Prompt 工程

- **复合 Prompt 设计**: 设计高效的 Prompt，引导 LLM 在单次调用中返回结构化数据（如 JSON），清晰地分离“优化建议”和“相似笔记”两个部分。
- **内容检索**: 在调用 LLM 前，需要一种高效的方式（如 Ripgrep 或内置 API）来收集知识库中所有笔记的标题或摘要，作为 LLM 的检索上下文。

### 6.4. 数据处理

- **Markdown 解析**: 高效的 Markdown 解析，仅读取文件头部以获取第一个一级标题。
- **JSON 持久化**: JSON 数据的序列化与反序列化，并处理持久化过程中的原子写入和错误恢复。
- **孤立问题发现**: 设计高效的扫描和对比算法，用于发现“孤立问题”。
- **数据恢复**: 如果 `tree.json` 或 `focused.json` 损坏或无法解析，插件应能优雅降级。例如，它可以将所有找到的 `.md` 文件视为“孤立问题”，允许用户从头开始重建视图结构，而不是完全崩溃。

### 6.5. 性能优化

- **标题缓存**: 全局缓存已解析的标题，避免重复 I/O 和解析。
- **懒加载**: 视图数据和文件内容按需加载。
- **防抖/节流**: 对文件监听事件和用户输入进行处理，避免高频触发更新操作。

### 6.6. 健壮性

- **配置检查与引导**: 在插件启动和命令执行时，检查 `issueManager.issueDir` 是否已配置。如未配置，通过视图消息和提示框引导用户完成设置，而不是直接报错。
- **拖拽验证**: 严格遵循 [2.5. 问题关联与结构操作](#25-问题关联与结构操作) 中定义的全局约束，确保拖入文件的类型和路径合法。
- **约束：防止循环引用（设计决策）**:
  - **问题场景**: 当用户在树状视图中，尝试将一个父节点（A）拖拽到其自身的子节点（B）上时，会产生循环引用的风险 (`A -> B -> A`)，导致插件在渲染时无限递归而崩溃。
  - **设计决策**: 插件**必须**阻止此操作。在执行任何建立父子关系的拖拽操作前，系统会进行前置检查，确保被拖拽的节点（A）不是目标节点（B）的祖先。如果检查发现会构成循环引用，操作将被取消。
  - **备选方案（已否决）**: 曾探讨过一种“节点移动并子级提升”的复杂逻辑。此方案因其交互结果模糊、不符合用户直觉且实现复杂而被否决。我们选择清晰的约束，而非易产生歧义的“智能”行为。
  - **详细讨论**: 关于此问题的详细思辨过程，请参见文档 [关于树状视图中节点拖拽导致循环引用的设计探讨](20250623-104627.md)。
- **引用管理**: 正确管理同一文件在树中多处引用的关系，确保删除一个引用不影响其他引用。
- **处理丢失文件**: 如果 `tree.json` 中引用的某个文件路径在磁盘上不存在（例如，文件被手动删除），插件不应崩溃。视图应能优雅地处理这种情况，例如在该节点旁显示一个“文件未找到”的警告图标，并允许用户解除此无效引用。
- **多根工作区支持**: 由于 `issueManager.issueDir` 使用绝对路径，因此它在多根工作区 (Multi-root Workspace) 环境下能无缝工作，其指向的目录独立于任何特定的工作区文件夹。

## [项目实施计划：问题管](20250622-101430.md)

[我想参考其他 vso](20250623-112250.md)

