# 问题管理插件需求文档

## 0. 名词统一 (Terminology)

为确保项目内部沟通、代码实现和文档的一致性，特此统一本项目中使用的核心名词及其定义。

### 核心概念

- **插件名称 (Plugin Name)**: **问题管理插件 (Issue Manager)**。本 VS Code 扩展的正式名称。
- **问题 (Issue)**: 插件管理的基本单元。每个“问题”在物理上对应“问题目录”中的一个独立的 Markdown (`.md`) 文件。
- **问题标题 (Issue Title)**: “问题”在界面中显示的名称。严格采用其 `.md` 文件中的第一个一级标题 (`#`)。若文件中无一级标题，则使用文件名（不含扩展名）作为后备标题。

### 核心目录

- **问题目录 (Issue Directory)**: 用户通过配置项 `issueManager.issueDir` 指定的一个**绝对路径**。它是存放所有“问题”文件 (`.md`) 的根目录。
- **数据目录 (Data Directory)**: 位于“问题目录”下的一个隐藏子目录 `.issueManager/`。它用于存放所有插件生成的元数据（如 `tree.json`, `focused.json`），确保整个知识库的自包含性和可移植性。

### 核心视图

- **问题总览 (Issue Overview)**: 主视图。以树状结构展示所有“问题”及其层级和关联关系。这是组织和管理问题的主要场所。
- **孤立问题 (Isolated Issues)**: 收件箱视图。以扁平列表形式展示所有存在于“问题目录”中，但尚未在“问题总览”视图中建立任何关联的“问题”。
- **关注问题 (Focused Issues)**: 过滤视图。以树状结构展示被用户标记为“关注”的“问题”及其完整的上下文（所有父级和子级节点）。
- **最近问题 (Recent Issues)**: 快速访问视图。展示用户近期创建或修改的所有问题，支持按时间分组或列表展示。

### 数据与操作

- **节点 (Node)**: `tree.json` 数据结构中的一个对象，代表对某个“问题”文件的一次**引用**。一个“问题”文件可以在“问题总览”树中被多次引用，每次引用都是一个具有唯一 `id` 的独立“节点”。
- **关联 (Association)**: 在视图中建立“节点”之间关系（如父子、同级）的操作，通常通过拖拽完成。此操作会修改 `tree.json` 文件。
- **解除关联 (Disassociation)**: 从“问题总览”树中移除一个“节点”引用的操作。此操作仅影响视图结构（修改 `tree.json`），**不会**删除物理上的 `.md` 文件。
  - **无子节点时**：直接解除关联，无需任何提示。
  - **有子节点（即存在子树）时**：操作前弹出确认提示：“该节点下包含子问题，解除关联将一并移除其所有子节点。是否继续？”用户确认后才执行解除。
- **添加/移除关注 (Focus/Unfocus)**: 将一个“问题”在“关注问题”视图中添加或移除的操作。此操作仅影响 `focused.json` 文件，不改变 `tree.json` 中的核心结构。

---

## 1. 概述

本插件旨在为 VS Code 用户提供一个强大的、集成的、基于视图的问题管理系统。它以本地 Markdown 文件作为数据源，帮助用户高效地创建问题、组织问题、建立问题间的层级和关联关系，并通过一个可定制的“关注”视图来追踪重要问题。

## 2. 核心功能与视图

插件的核心功能围绕着一个智能创建流程和三个核心视图展开。

### 2.1. 智能新建问题

这是插件最核心的入口功能，旨在通过 LLM 赋能，提供一个从想法捕捉到知识入库的无缝体验。

#### 2.1.1. 用户故事

- 作为一名用户，我希望能快速记录一个想法，而不必担心措辞是否完美或知识库中是否已有相关内容。
- 作为一名用户，我希望系统能帮我把随意的想法（如“怎么改 vscode 颜色”）优化成清晰的标题（如“如何修改 VS Code 的主题颜色？”）。
- 作为一名用户，我希望在创建新笔记前，能立即看到可能相关的已有笔记，避免信息孤岛和重复劳动。
- 作为一名用户，我希望整个过程是流畅的，最好在一个界面完成所有选择，而不是分好几步。

#### 2.1.2. 核心工作流程

1. **触发 (Trigger):**
   - 用户通过快捷键 (例如 `Cmd+Shift+N`) 或从命令面板运行 `issueManager.createIssue` 命令。

2. **输入问题 (Input Question):**
   - VS Code 顶部出现一个 Quick Pick 输入框，提示用户输入问题 (Placeholder text: "请输入您的问题...")。
   - 用户输入问题后按 `Enter` 键确认。

3. **统一智能处理 (Unified Intelligence Processing):**
   - 插件将用户的原始输入文本发送给 LLM。
   - LLM 执行一个**复合任务 (Compound Task)**，其 Prompt 经过精心设计，要求模型**在一次调用中同时返回两类信息**：
     - **A. 问题优化建议 (Optimized Phrasings):** 3-4个对原始输入的重述、修正或优化后的版本。
     - **B. 相似笔记检索 (Similar Notes):** 在用户知识库（工作区内的 `.md` 文件）中检索出的最多5个语义最相关的已有笔记。

4. **统一选择界面 (Unified Quick Pick):**
   - 系统**立即**弹出一个 `Quick Pick` 列表，并显示加载状态 (`busy = true`)。
   - 列表的初始内容是用户的原始输入，允许用户不等待 LLM 直接创建。
   - 当 LLM 返回结果后，列表动态更新，最终呈现一个合并后的选项清单，结构如下：
     - `[创建新笔记] {用户原始输入}`
     - `[创建新笔记] {LLM 优化建议 1}`
     - `[创建新笔记] {LLM 优化建议 2}`
     - --- 分隔线 ---
     - `[打开已有笔记] {相似笔记 1 的标题}`
     - `[打开已有笔记] {相似笔记 2 的标题}`
     - ...
   - **支持多选**：用户可在 Quick Pick 中同时多选任意数量的“[创建新笔记]”和“[打开已有笔记]”项。

5. **执行操作 (Action):**
   - **选择一个或多个 `[创建新笔记]` 与/或 `[打开已有笔记]` 项：**
     - 所有被选中的“[创建新笔记]”项将依次新建 Markdown 文件，标题为所选文本，文件名为 `YYYYMMDD-HHmmss-SSS.md`，并自动打开。
     - 所有被选中的“[打开已有笔记]”项将依次打开对应的 Markdown 文件。
     - 如果当前为“新建子问题”或“插入到父节点”等场景，被选中的“[打开已有笔记]”项也会自动插入到父节点下（即建立树结构关联）。
     - 新建与打开可同时发生，所有文件将依次在编辑器中打开。
   - **按 `Esc` 取消:**
     - 流程中断，不执行任何操作。

### 2.1.3. Language Model Tool 集成 (AI 聊天内容记录)

为了进一步提升用户的知识捕捉体验，插件还提供了与 VS Code Copilot 聊天的深度集成功能，支持用户在聊天过程中直接将重要内容记录到问题管理系统中。

#### 核心功能

- **无缝集成**: 通过 VS Code Language Model Tool API，插件在 Copilot 聊天环境中注册了一个内容记录工具，用户无需离开聊天界面即可保存重要讨论内容。
- **智能触发**: 当用户在聊天中输入特定短语时，Copilot 会自动识别用户意图并调用记录工具：
  - "创建文档"
  - "创建笔记"
  - "新建笔记"
  - "新建问题"
  - "保存为文档"
  - 以及其他类似的表达方式

#### 工作流程

1. **用户触发**: 用户在与 Copilot 的聊天中表达记录意图
2. **AI 理解**: Copilot 识别用户意图，自动调用 `recordContent` 工具
3. **内容生成**: LLM 分析聊天上下文，生成完整的 Markdown 文档内容，包括：
   - 自动提取的标题
   - 格式化的正文内容
   - 上下文信息（如创建时间、来源等）
   - 适当的 Markdown 格式化
4. **用户确认**: 系统显示确认对话框，预览将要创建的文档标题和内容
5. **文档创建**: 用户确认后，插件自动：
   - 在问题目录中创建新的 Markdown 文件（文件名格式：`YYYYMMDD-HHmmss-SSS.md`）
   - 打开新创建的文档
   - 刷新插件视图，新文档将出现在"孤立问题"视图中

#### 技术特点

- **上下文感知**: 直接获取聊天上下文，无需用户手动复制粘贴
- **自动格式化**: LLM 自动将聊天内容转换为结构化的 Markdown 文档
- **一致性**: 创建的文档与通过其他方式创建的问题文件完全一致
- **错误处理**: 提供完善的错误处理和恢复机制，确保功能稳定可靠

#### 与传统智能创建的区别

1. **触发方式**: 在聊天环境中自然触发，而非通过命令面板
2. **内容来源**: 基于聊天上下文生成内容，而非用户手动输入标题
3. **自动化程度**: 更高度的自动化，LLM 负责内容的完整生成和格式化
4. **使用场景**: 适用于记录讨论结果、保存解决方案、归档重要对话等场景

### 2.2. 问题总览 (Issue Overview)

此视图是问题的主要管理界面，以树状结构展示所有问题及其关系。

- **功能**:
  - **树状展示**: 清晰地展示问题之间的父子、依赖等层级关系。
  - **创建问题**: 可以通过视图顶部的 `+` 按钮或右键菜单创建新的顶层问题或子问题。
  - **解除关联**: 右键点击问题，可以解除其在树中的关联。此操作仅从视图中移除节点引用，不删除物理文件。若节点无子问题，则直接解除；若有子问题，则在操作前弹出确认提示。
  - **关联问题**: 支持通过拖拽操作灵活地组织问题。详细规则请参见 [2.5. 问题关联与结构操作](#25-问题关联与结构操作)。
  - **多重引用**: 同一问题（Markdown 文件）可在树中多处引用，实现灵灵活分类。
  - **添加到关注**: 右键点击问题，提供 "添加到关注" 选项，可将问题添加到 `关注问题` 视图中进行追踪。
  - **批量操作**: 支持通过多选对问题进行批量操作（如批量解除关联、移动、添加至关注等）。
  - **复制文件名**: 右键点击问题，提供“复制文件名”选项，可将问题对应的文件名（如 `20250708-103000-000.md`）复制到剪贴板。

### 2.3. 孤立问题 (Isolated Issues)

此视图作为新问题的收件箱，所有被创建但尚未建立任何关联的问题都会在这里列出。

- **功能**:
  - **自动发现**: 自动扫描配置的笔记路径，找出所有未在 `问题总览` 树中引用的 `.md` 文件（孤立问题），并以列表形式展示。
  - **列表展示**: 以扁平列表形式展示所有孤立的问题。
  - **排序方式**: 列表中的问题默认按**文件创建时间倒序**排列，确保最新的问题显示在最顶部，方便用户快速处理新条目。
  - **实时刷新**: 列表实时刷新，响应工作区文件的增、删、改变化。
  - **问题来源**: 通过命令面板 (Command Palette) 创建的新问题将首先出现在此视图中。
  - **问题归类**:
    - **支持**: 从本视图拖拽问题到 `问题总览` 或 `关注问题` 视图中，可以为其建立父子关系，使其不再孤立。此操作会更新 `tree.json` 并将问题从本视图移除。详细规则请参见 [2.5. 问题关联与结构操作](#25-问题关联与结构操作)。
    - **不支持**: `孤立问题` 视图是一个只进不出的“收件箱”。因此，**不支持**从 `问题总览` 或 `关注问题` 视图向本视图进行任何拖拽操作。
  - **删除问题**:
    - **功能**: 右键点击一个或多个孤立问题，提供“删除”选项。
    - **复制文件名**: 右键点击问题，提供“复制文件名”选项。
    - **操作**: 执行此操作将从磁盘上**物理删除**对应的 `.md` 文件。
    - **确认**: 为防止误操作，执行删除前**必须**弹出一个确认对话框，明确告知用户文件将被永久删除。

### 2.4. 关注问题 (Focused Issues)

此视图是“问题总览”视图的一个交互式、过滤后的镜像，旨在帮助用户追踪核心任务。其交互功能与“问题总览”视图基本保持一致。

- **功能**:
  - **聚焦展示**: 以树状结构呈现所有被标记为“关注”的问题及其所有子级节点。与“问题总览”不同，此视图**不会**直接展示其祖先节点，从而保持列表的简洁性。
  - **排序方式**: 根节点默认按**添加关注的时间倒序**排列，确保最新的关注项显示在最顶部。
  - **父级路径提示**: 为了在不牺牲简洁性的前提下提供上下文，对于直接被关注的根节点，其右侧将以描述（description）的形式展示其在“问题总览”视图中的完整父级路径（例如 `/ 祖先问题 / 父问题`），而其子节点则不显示，以保持视图简洁。
  - **结构同步与操作**: 本视图中的所有结构操作（如创建、删除、关联）与“问题总览”完全同步，并遵循相同的交互规则。详细规则请参见 [2.5. 问题关联与结构操作](#25-问题关联与结构操作)。
  - **创建问题**: 可以通过右键菜单创建新的顶层问题或子问题，操作方式与“问题总览”一致。
  - **解除关联**: 支持右键点击问题节点，解除其在关注视图中的结构关联，操作逻辑与“问题总览”一致（仅影响结构，不删除文件）。
  - **移除关注**: 右键点击问题，提供“移除关注”选项。此选项**仅对被直接设为关注的一级节点可用**，执行后会将其从本视图中移除（不影响其在“问题总览”中的存在）。
  - **置顶关注 (Pin Focus)**: 右键点击**非置顶**的关注问题，提供“置顶”选项。执行后，该问题将在“关注问题”视图中被移动到列表的最顶部。此操作仅对根节点（被直接设为关注的节点）可用，且列表中的第一个问题不会显示此选项。
  - **复制文件名**: 右键点击问题，提供“复制文件名”选项。

### 2.5. 最近问题 (Recent Issues)

此视图旨在提供一个快速访问入口，集中展示用户近期创建或修改的所有问题，无论它们是否已被关联。它提供了两种展示模式，以满足不同场景下的回顾需求。

- **功能**:
  - **双模式展示**: 在视图的标题栏提供一个切换按钮（例如“分组/列表”图标），允许用户在以下两种模式间切换：
    1.  **列表模式 (List View)**: 默认模式。以扁平列表形式，展示位于 `issueManager.issueDir` 目录下的所有 `.md` 文件，并按**文件最后修改时间倒序**排列。
    2.  **分组模式 (Grouped View)**: 以树状结构，按照相对时间对问题进行分组展示，便于结构化回顾。
  - **智能分组策略 (在分组模式下)**:
    -   **一级分组**: `今天`, `昨天`, `最近一周`, `最近一月`, `更早`。
    -   **二级分组**:
        -   在 `最近一周` 下，按具体的日期和星期 (`7月5日 星期六`) 进行分组。
        -   在 `最近一月` 下，按 `本周`, `上周`, `第XX周` 进行分组。
    -   **三级分组**: 在周分组下，再按具体的日期和星期进行分组。
  - **实时刷新**: 视图会通过文件监听器实时响应文件的创建和修改，动态更新列表和分组。
  - **快速归类**: 支持从本视图拖拽问题到 `问题总览` 或 `关注问题` 视图中，为其建立关联或添加关注。
  - **只读结构**: 与“孤立问题”视图类似，本视图是一个动态查询结果，**不支持**从其他视图向其进行任何拖拽操作。
  - **复制文件名**: 右键点击问题，提供“复制文件名”选项。

### 2.6. 问题关联与结构操作 (Issue Association and Structural Operations)

这是 `问题总览` 和 `关注问题` 视图共享的核心交互功能，主要通过拖拽 (Drag and Drop) 实现。

- **拖拽来源 (Drag Sources)**:
  - **从各视图拖拽**:
    - `问题总览` 与 `关注问题`: 从这两个视图中拖拽一个或多个已有问题节点。
    - `孤立问题`: 从此视图中拖拽一个或多个孤立问题，以将其纳入结构。
    - `最近问题`: 从此视图中拖拽一个或多个问题，以将其纳入结构。
  - **从编辑器拖拽**:
    - 从 **编辑器标签页** 拖拽一个 `.md` 文件。

- **拖拽目标与行为 (Drop Targets and Behaviors)**:
  - **拖拽到一个问题上**: 将被拖拽的问题（或文件）添加为目标问题的**子问题**。
  - **拖拽到两个问题的间隙**: 将被拖拽的问题（或文件）作为同级，插入到间隙对应位置。
  - **拖拽到视图的空白区域**: 将被拖拽的问题（或文件）添加为**顶层根问题**。

- **全局约束 (Global Constraints)**:
  - **文件类型**: 所有从外部（如编辑器）拖入的项目必须是 `.md` 文件。
  - **文件路径**: 为了维护知识库的完整性，从编辑器拖入的 `.md` 文件，其路径**必须**位于用户配置的 `issueManager.issueDir` 目录之内。插件将拒绝关联此目录之外的文件。

### 2.7. 拖拽到编辑器生成链接 (Drag to Editor for Link)

- 允许用户从 `问题总览`、`孤立问题`、`关注问题` 或 `最近问题` 视图中拖拽任意问题项到文本编辑器中。
  - **行为**: 如果目标编辑器是 Markdown 文件，并且其自身也位于配置好的“问题目录” (`issueManager.issueDir`) 下，则在光标位置插入一个指向该问题的 Markdown 链接 (例如 `[问题标题](<link-to-issue>)`)。

### 2.8. 视图与编辑器的双向联动 (View and Editor Sync)

- **从视图到编辑器 (Reveal in Editor)**: 在任意问题视图 (`问题总览`, `孤立问题`, `关注问题`, `最近问题`) 中单击问题项，应在编辑器中打开对应的 Markdown 文件。
- **从编辑器到视图 (Reveal in Tree View)**: 当用户在编辑器中打开并激活一个属于“问题目录”的 Markdown 文件时，`问题总览`, `孤立问题` 和 `关注问题` 视图应自动展开并高亮显示对应的文件节点。

### 2.9. 启动与配置引导 (Onboarding)

- **前置条件**: 插件的核心功能依赖于用户设置“问题目录” (`issueManager.issueDir`)。
- **启动检查与上下文设置**:
  - 插件激活时，会检查 `issueManager.issueDir` 配置是否存在。
  - 同时，它会通过 `vscode.commands.executeCommand('setContext', 'issueManager.isDirConfigured', ...)` 设置一个全局的布尔值上下文。这个上下文的值会根据配置是否存在而实时更新（例如，在启动时和配置变更时）。
- **未配置状态下的视图 (View Welcome Content)**:
  - 如果 `issueManager.issueDir` 未设置（即 `issueManager.isDirConfigured` 上下文为 `false`），所有核心视图 (`问题总览`, `孤立问题`, `关注问题`, `最近问题`) 将不会加载问题数据。
  - 相反，每个视图会利用 VS Code 的 `viewsWelcome` 贡献点，显示一段引导信息，例如：“请先配置问题目录以激活插件功能。”
  - 这段信息中会包含一个可点击的、命令驱动的链接，如“**[立即配置]**”，它直接链接到打开设置的命令。
- **引导操作**:
  - 点击“立即配置”链接后，将自动打开当前工作区的 `settings.json` 文件，并聚焦到 `issueManager.issueDir` 配置项，方便用户快速填写。
  - 一旦用户保存了有效的目录配置，`issueManager.isDirConfigured` 上下文会自动变为 `true`，`viewsWelcome` 内容随之消失，所有视图和命令将自动激活并正常工作。

## 3. 命令 (Commands)

插件应在命令面板中注册以下命令：

- `issueManager.createIssue`: 通过一个由 LLM 赋能的智能流程快速创建新问题。详细工作流程请参见“核心功能与视图”一节。新创建的问题将出现在 `孤立问题` 视图中。
- `issueManager.focusIssue`: (在 `问题总览` 视图中通过右键菜单触发) 将选中的问题添加到 `关注问题` 视图中。
- `issueManager.removeFocus`: (在 `关注问题` 视图中通过右键菜单触发) 将选中的问题从 `关注问题` 视图中移除。
- `issueManager.pinFocus`: (在 `关注问题` 视图中通过右键菜单触发) 将选中的问题在关注列表中置顶。

## 4. 数据模型与存储

为了实现数据的可移植性和自包含性，所有与本插件相关的数据文件（视图结构、缓存等）都将存储在用户配置的“问题目录”下的一个隐藏子目录 `.issueManager/` 中。

### 4.1. 数据存放核心注意事项

- **统一存放位置**: 所有数据文件，包括 `tree.json` 和 `titleCache.json`，都将被存放在 `<issueDir>/.issueManager/` 目录下。这使得整个知识库（包含源文件和结构数据）可以被轻松地复制、移动或通过版本控制同步。
- **自动创建与管理**:
  - 当用户首次配置 `issueManager.issueDir` 后，插件会自动在后台创建 `.issueManager` 子目录。
  - 为方便版本控制，插件会在 `.issueManager/` 目录中自动创建一个 `.gitignore` 文件，内容为 `titleCache.json`，以确保缓存文件不会被意外提交。
- **新版存储方案**:
  - 本版本采用全新的数据存储方案，不再支持从旧版本（如存储在 `.vscode/` 目录下）自动迁移数据。这是一个更稳定、更可移植的全新开始。
- **权限检查**: 在尝试写入任何数据前，插件会检查对 `.issueManager/` 目录是否拥有写权限，并在权限不足时向用户发出明确提示。
- **处理问题目录变更**: 当插件检测到 `issueManager.issueDir` 的配置发生变化时，它将执行以下检查：
  - **检查新目录**: 插件会立即检查新的 `issueManager.issueDir` 路径下是否存在 `.issueManager/` 子目录。
  - **找到数据**: 如果 `.issueManager/` 存在，插件会加载其中的数据（`tree.json`, `focused.json` 等），并无缝衔接工作。这被视为用户已将整个问题库（源文件和 `.issueManager` 目录）移动到了新位置。
  - **未找到数据**: 如果 `.issueManager/` **不**存在，插件会将其视为一个全新的、空的知识库。它将自动在后台创建 `.issueManager` 子目录及必要的初始文件（如空的 `tree.json`），为用户提供一个即时可用的新环境。

### 4.2. 问题树结构数据 (`tree.json`)

- **数据存储**: 所有问题的**视图结构**（如层级、折叠状态等）将存储在 `<issueDir>/.issueManager/tree.json` 文件中。
- **用途**: 持久化 `问题总览` 视图的树状结构。
- **数据结构**:

    ```json
    {
      "version": "1.0.0",
      "lastModified": "2025-06-18T19:16:51.000Z",
      "rootNodes": [
        {
          "id": "node-uuid-1",
          "filePath": "/path/to/note-as-folder.md",
          "expanded": true,
          "children": [
            {
              "id": "node-uuid-2",
              "filePath": "/path/to/note.md",
              "children": []
            },
            {
              "id": "node-uuid-3",
              "filePath": "/path/to/another-note.md",
              "children": []
            }
          ]
        }
      ]
    }
    ```

- **节点属性说明**:
  - **id**: 唯一标识符 (UUID)。
  - **filePath**: 问题的 markdown 文件在磁盘上的**相对路径**（相对于 `issueDir` 目录）。这种设计确保了项目结构的内部一致性。如果整个问题目录被移动，用户**必须**在 VS Code 设置中更新 `issueManager.issueDir` 的绝对路径，但 `tree.json` 文件本身无需修改。
  - 如果文件在 `issueDir` 内部，路径是直接的相对路径，例如：`issues/issue-172839.md`。
  - 如果文件在 `issueDir` 外部，路径会包含 `../` 来向上导航，例如：`../../docs/related-note.md`。
  - 插件在加载时，需要将这个相对路径与 `issueManager.issueDir` 的绝对路径结合，来解析出文件的最终绝对路径。
- **children**: 子问题节点的数组，递归地定义了树的层级关系。

#### 示例 `tree.json`

```json
{
  "version": "1.0.0",
  "lastModified": "2025-06-18T19:16:51.000Z",
  "rootNodes": [
    {
      "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
      "filePath": "issues/issue-1.md",
      "expanded": true,
      "children": [
        {
          "id": "b2c3d4e5-f6a7-8901-2345-67890abcdef0",
          "filePath": "issues/issue-2.md",
          "children": []
        }
      ]
    }
  ]
}
```

#### 4.3 focused.json 数据结构

- **数据存储**: 所有被标记为“关注”的**节点 ID** 列表将存储在 `<issueDir>/.issueManager/focused.json` 文件中。
- **用途**: 持久化 `关注问题` 视图的状态。
- **数据结构**:

    ```json
    {
      "version": "1.0.0",
      "focusList": [
        "a1b2c3d4-e5f6-7890-1234-567890abcdef"
      ]
    }
    ```

- **属性说明**:
  - **version**: 数据结构版本。
  - **focusList**: 被关注问题的**节点 ID (`uuid`)** 列表。这些 ID 与 `tree.json` 中定义的节点 `id` 相对应。

#### 示例 `focused.json`

```json
{
  "version": "1.0.0",
  "focusList": [
    "a1b2c3d4-e5f6-7890-1234-567890abcdef"
  ]
}
```

#### 4.4 titleCache.json 数据结构

为了在不读取每个文件内容的情况下快速显示问题的标题，插件维护一个标题缓存。

- **文件结构**: 一个简单的 JSON 对象，将文件的**相对路径**（相对于 `issueDir` 目录）映射到其标题。
- **更新时机**:
  - 当一个问题被创建或标题被修改时，此缓存会同步更新。
  - 插件启动时，可以校验缓存的有效性。

#### 示例 `titleCache.json`

```json
{
  "issues/issue-1.md": "Root Issue",
  "issues/issue-2.md": "Sub Issue 1"
}
```

### 4.2.1. 节点展开/折叠状态的同步与持久化

为提升多视图（如“问题总览”与“关注问题”）下的用户体验，插件实现了节点展开/折叠状态的持久化与同步，具体方案如下：

- **展开状态字段**：
  - 每个节点对象包含 `expanded` 字段（布尔值），用于记录该节点当前是否为展开状态。
  - 该字段持久化存储在 `tree.json` 的每个节点对象中。

- **事件监听与写入**：
  - 插件通过 VS Code TreeView API 的 `onDidExpandElement` 和 `onDidCollapseElement` 事件，监听用户在任一视图中的展开/折叠操作。
  - 每次操作后，自动调用统一的工具函数递归查找并更新对应节点的 `expanded` 字段，并写入 `tree.json`。

- **多视图同步**：
  - “问题总览”与“关注问题”视图均以 `tree.json` 为唯一数据源，任一视图的展开/折叠操作都会实时反映到另一视图。
  - 每次任一视图刷新时，均从 `tree.json` 读取最新的 `expanded` 状态，确保 UI 状态一致。

- **渲染还原**：
  - TreeDataProvider 的 `getTreeItem` 方法会根据节点的 `expanded` 字段，设置 `TreeItem.collapsibleState`，从而还原上次的展开/折叠状态。

- **实现要点**：
  - 提供递归查找并更新节点 `expanded` 字段的工具函数，保证任意层级节点都能正确同步状态。
  - 通过统一的刷新命令，确保所有相关视图在数据变更后自动刷新。

> ⚠️ 注意：TreeView 的 `TreeItem.collapsibleState` 属性只在节点**首次渲染**时生效。后续即使数据源（如 expanded 字段）发生变化，VSCode 也不会自动根据新的 collapsibleState 重新渲染节点的展开/折叠状态。要实现动态同步，需结合事件监听与刷新机制。

> 该机制保证了多视图下节点展开/折叠状态的高度一致性和持久化，极大提升了插件的易用性和专业性。

### 4.5. 数据校验与健壮性 (Data Validation and Robustness)

为防止用户手动编辑 `tree.json` 等数据文件时可能引入的错误，插件在加载时会执行严格的数据校验流程，以确保系统的健壮性。

- **JSON Schema 验证**:
  - 插件将为 `.issueManager/` 目录下的核心数据文件（如 `tree.json`, `focused.json`）提供 JSON Schema。
  - 当用户在 VS Code 中直接打开这些 JSON 文件时，可以获得实时语法检查、自动补全和属性说明，从而极大地降低手动编辑出错的概率。

- **启动时完整性检查**:
  - 每次加载数据时，除了基本的 JSON 语法解析，插件还会在内存中执行一系列完整性检查：
  1. **文件引用校验**: 遍历 `tree.json` 中的所有节点，检查每个 `filePath` 指向的文件是否真实存在于磁盘上。对于不存在的文件，将按 [6.6. 健壮性](#66-健壮性) 中“处理丢失文件”的策略进行处理。
  2. **ID 唯一性与一致性**: 确保 `tree.json` 内的所有节点 `id` 都是唯一的。同时，校验 `focused.json` 中的每一个 `id` 都能在 `tree.json` 中找到对应的节点。无效的 `id` 将被静默忽略。
  3. **循环引用检测**: 在构建树状结构时，检测是否存在循环引用（例如，一个节点是自身的祖先）。如果检测到循环，将断开循环链接并记录警告，防止无限递归。

- **损坏文件恢复机制**:
  - 如果在上述任何一个校验环节（包括 JSON 语法解析）失败，插件会认为该数据文件已损坏。
  - 此时，插件会：
  1. 向用户显示一条明确的错误通知，说明哪个文件已损坏，无法加载。
  2. 将损坏的文件备份（例如，重命名为 `tree.json.bak`）。
  3. 启动**安全恢复模式**：忽略损坏的结构文件，将 `issueDir` 目录下的所有 `.md` 文件全部加载到“孤立问题”视图中。
  - 这种机制确保了即使结构文件损坏，用户的核心笔记内容也绝不会丢失，并且可以方便地重新组织和恢复其结构。

## 5. 配置项

用户可以通过 VS Code 的 `settings.json` 文件对插件进行配置。

- **`issueManager.issueDir`**: (字符串) **必须是绝对路径**。指定一个本地文件系统上的目录，作为存放所有新建问题文件的“问题目录”。例如: `"/Users/user/Documents/MyNotes"`。
- **`issueManager.createIssue.enableIntelligence`**: (布尔值) 启用/禁用创建问题时的 LLM 增强功能。
- **`issueManager.createIssue.similarResultsCount`**: (数字) 配置返回的相似问题数量。
- **`issueManager.createIssue.optimizedPhrasingsCount`**: (数字) 配置 LLM 生成的优化建议数量。

## 6. 总体技术要点

### 6.1. VS Code API

- **视图实现**: 实现 `TreeDataProvider` 接口来提供 `问题总览`、`孤立问题`、`关注问题` 和 `最近问题` 四个视图的数据。
- **拖拽处理**: 实现 `DragAndDropController` 来处理视图内部以及视图与编辑器之间的拖拽操作。
- **文件监听**: 使用 `FileSystemWatcher` 监听工作区内 `.md` 文件的增、删、改，以实时刷新视图和缓存。
- **智能输入框**: 充分利用 `vscode.window.createQuickPick` 的高级功能，包括设置 `busy` 状态和动态更新 `items` 列表，以实现异步加载的统一选择界面。

### 6.2. “关注视图”实现方案

采用**“结构与状态分离”**的设计模型，将问题的核心层级关系与用户的“关注”状态分别存储，以实现高性能渲染和清晰的逻辑。

- **数据模型**:
  - **`tree.json` (结构文件)**: 作为单一的、权威的结构数据源，存储所有问题的层级关系。
  - **`focused.json` (状态文件)**: 仅记录被标记为“关注”的问题ID列表，不包含任何层级信息。

- **视图渲染逻辑**:
  1. **数据读取**: 同时加载 `tree.json` 的完整结构树和 `focused.json` 的关注ID列表。
  2. **节点过滤**: `FocusedIssuesProvider` 遍历 `tree.json`，找出所有在 `focused.json` 列表中被引用的节点。
  3. **渲染呈现**: 将找到的节点（及其完整的后代子树）作为根节点，渲染到“关注问题”视图中。
  4. **上下文提示**: 在渲染每个列表项时 (`getTreeItem`)，为其动态生成并附加一个 `tooltip`，该 `tooltip` 通过向上查找节点的祖先链来实时生成路径字符串。

- **双向同步机制**:
  - **结构性变更 (如拖拽)**: 无论在哪个视图操作，都直接修改底层的 `tree.json`，然后通知**两个**视图刷新。
  - **状态性变更 (添加/移除关注)**: 仅修改 `focused.json`，然后通知“关注视图”刷新。

### 6.3. LLM 集成与 Prompt 工程

- **复合 Prompt 设计**: 设计高效的 Prompt，引导 LLM 在单次调用中返回结构化数据（如 JSON），清晰地分离“优化建议”和“相似笔记”两个部分。
- **内容检索**: 在调用 LLM 前，需要一种高效的方式（如 Ripgrep 或内置 API）来收集知识库中所有笔记的标题或摘要，作为 LLM 的检索上下文。

### 6.4. 数据处理

- **Markdown 解析**: 高效的 Markdown 解析，仅读取文件头部以获取第一个一级标题。
- **JSON 持久化**: JSON 数据的序列化与反序列化，并处理持久化过程中的原子写入和错误恢复。
- **孤立问题发现**: 设计高效的扫描和对比算法，用于发现“孤立问题”。
- **数据恢复**: 如果 `tree.json` 或 `focused.json` 损坏或无法解析，插件应能优雅降级。例如，它可以将所有找到的 `.md` 文件视为“孤立问题”，允许用户从头开始重建视图结构，而不是完全崩溃。

### 6.5. 性能优化

- **标题缓存**: 全局缓存已解析的标题，避免重复 I/O 和解析。
- **懒加载**: 视图数据和文件内容按需加载。
- **防抖/节流**: 对文件监听事件和用户输入进行处理，避免高频触发更新操作。

### 6.6. 健壮性

- **配置检查与引导**: 在插件启动和命令执行时，检查 `issueManager.issueDir` 是否已配置。如未配置，通过视图消息和提示框引导用户完成设置，而不是直接报错。
- **拖拽验证**: 严格遵循 [2.5. 问题关联与结构操作](#25-问题关联与结构操作) 中定义的全局约束，确保拖入文件的类型和路径合法。
- **约束：防止循环引用（设计决策）**:
  - **问题场景**: 当用户在树状视图中，尝试将一个父节点（A）拖拽到其自身的子节点（B）上时，会产生循环引用的风险 (`A -> B -> A`)，导致插件在渲染时无限递归而崩溃。
  - **设计决策**: 插件**必须**阻止此操作。在执行任何建立父子关系的拖拽操作前，系统会进行前置检查，确保被拖拽的节点（A）不是目标节点（B）的祖先。如果检查发现会构成循环引用，操作将被取消。
  - **备选方案（已否决）**: 曾探讨过一种“节点移动并子级提升”的复杂逻辑。此方案因其交互结果模糊、不符合用户直觉且实现复杂而被否决。我们选择清晰的约束，而非易产生歧义的“智能”行为。
  - **详细讨论**: 关于此问题的详细思辨过程，请参见文档 [关于树状视图中节点拖拽导致循环引用的设计探讨](20250623-104627.md)。
- **引用管理**: 正确管理同一文件在树中多处引用的关系，确保删除一个引用不影响其他引用。
- **处理丢失文件**: 如果 `tree.json` 中引用的某个文件路径在磁盘上不存在（例如，文件被手动删除），插件不应崩溃。视图应能优雅地处理这种情况，例如在该节点旁显示一个“文件未找到”的警告图标，并允许用户解除此无效引用。
- **多根工作区支持**: 由于 `issueManager.issueDir` 使用绝对路径，因此它在多根工作区 (Multi-root Workspace) 环境下能无缝工作，其指向的目录独立于任何特定的工作区文件夹。

## [项目实施计划：问题管](20250622-101430.md)

[我想参考其他 vso](20250623-112250.md)
